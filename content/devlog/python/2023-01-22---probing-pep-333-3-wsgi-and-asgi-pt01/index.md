---
title: "PEP 공부해보기 - PEP 333, PEP 3333에 대하여 (1)"
date: "2023-01-22T23:57:00.000Z"
template: "post"
draft: false
slug: "/devlog/python/2023-01-22-probing-pep-333-3-wsgi-and-asgi-pt01"
category: "devlog"
tags:
  - "python"
  - "PEP"
description: "PEP 시리즈 - PEP 333, PEP 3333 을 탐구합니다."
socialImage: { "publicURL": "./media/exotic_shorthair.jpg" }
---

# 시리즈 안내

- PEP 333
- PEP 249

# 연재 안내

- PEP 333 (1)

# 들어가며

이번 시리즈에서는 파이썬에서 사용하는 웹 프레임워크 인터페이스의 근본부터 이해하고, 이에 대한 이해를 통해 사용하는 프레임워크가 어떤 식으로 작성되었나 이해해보고자 합니다.

따라서 모든 내용을 이해하는 것이 아니라, 필요한 사항에 대해 PEP 문서상의 내용을 참고하여 작성하는 것이 이번 글의 목표입니다.

# 논외로 두려 하는 사항

자주 쓰는 CPython 구현체 뿐 아니라 PyPy, Jython, IronPython 등의 파이썬 플랫폼 모두를 아우르는 글이 PEP 입니다만, 거기까지 다룰 자신도 없고 제대로 말씀드리기도 어려울 듯 합니다...

따라서, CPython 으로 작성하겠습니다.

# PEP 333, PEP 3333

- 웹 서버와 파이썬 웹 앱/프레임워크와의 인터페이스를 제안한 문서입니다.
  - 이 문서는 2003년에 최초로 생성되었습니다(!)
- Python 3 버전에 맞추어서 새로 나온 PEP 3333을 같이 보도록 하겠습니다.
  - 이에 대해선 [귀도 판 로섬의 메일](https://mail.python.org/pipermail/python-dev/2010-September/104114.html)을 살펴보세요.

# Rationale and Goals

- 해당 PEP 발표 당시 파이썬도 웹 애플리케이션이 많이 등장했으나, 웹 및 서버-웹 앱의 선택이 한정적이었습니다.
- 한편 자바는 [servlet API](https://www.geeksforgeeks.org/servlet-api/) 를 통해 어떤 자바 앱이든 웹 서버-웹 앱 간 상호작용이 가능하도록 했습니다.
- 그 시절 파이썬은 웹 통신을 위한 구현체가 따로따로 있었습니다.
  - 예를 들어 아래 구현체들이 있습니다:
    - 파이썬으로 작성된 웹서버 ([Medusa, 아카이브](https://github.com/lispyclouds/medusa))
    - 웹 서버에 임베딩되어 쓰이는 형식 ([mod_python, 코드는 관리되나 더이상 업데이트 없음](https://github.com/grisha/mod_python))
    - 게이트웨이 프로토콜을 통해 파이썬을 호출한 방식 ([CGI, 정의만 있음](https://www.w3.org/CGI/), FastCGI)
      - CGI(Common Gateway Interface)는 다음에 더 추가적으로 설명하도록 하겠습니다
- PEP 333은 이런 불편을 덜기 위해 **_웹 서버-웹 앱 간의 인터페이스, 즉 WSGI(Python Web Server Gateway Interface)를 제안_** 한 내용입니다.
  - 별도의 WSGI 구현 에 대한 제한을 두어 필요한 사람들이 이를 보고 웹 프레임워크를 만들 수 있게끔 하는 것이 목적입니다.
  - WSGI의 구현체는 최대한 단순하면서도 파이썬 기본 라이브러리만을 사용하여 구현해야하고, `2.2.2`(PEP 333 기준) 버전 이상의 파이썬 버전을 요하지 않습니다.
    - 이에 대해선 아래에서 다시 서술하겠습니다.
- 요청, 응답에 대한 구현 뿐 아니라 WSGI 기반의 추가적인 **_미들웨어(middleware)_** 구성요소를 만들어 요청, 응답에 필요한 추가적인 작업을 수행할 수 있도록 합니다.
  - 단순하고, 견고하고, 느슨하게 결합된 미들웨어로 구성된 프레임워크가 충분히 만들어질 수 있습니다.

# Specification Overview

- WSGI 인터페이스는 "서버(혹은 게이트웨이)" 사이드, "앱(혹은 프레임워크) 사이드" 가 있습니다.
- 서버 사이드는 `Callable` 객체[1]를 호출합니다. 이 객체는 앱 사이드에서 제공하는 값입니다.
  - Callable 객체가 어떻게 제공되는지는 서버/게이트웨이가 정하기 나름입니다.
    - 일부 서버 또는 게이트웨이는 응용 프로그램 배포자가 서버 또는 게이트웨이의 인스턴스를 만들고
      응용 프로그램 개체와 함께 제공하는 짧은 스크립트를 작성해야 한다고 가정합니다.
    - 다른 서버 및 게이트웨이는 구성 파일 또는 기타 메커니즘을 사용하여 응용 프로그램 개체를 가져오거나 다른 방식으로 가져와야 하는 위치를 지정할 수 있습니다.
- 서버/게이트웨이, 앱/프레임워크 사이에 존재하는 "미들웨어"라는 것을 구현할 수 있습니다.
  - 이는 "미들웨어"를 포함하는 서버의 앱처럼, 혹은 애플리케이션에 포함된 서버처럼 쓰일 수도 있습니다.
  - 확장 API, 컨텐츠 변환, 탐색 등의 기타 유용한 기능을 추가로 제공해줄 수 있습니다.

음, 번역해보니 이런 내용이 있군요. 추가사항 몇 가지를 더 살펴보고 나서 구현체로 살펴봅시다.

## 문자열 타입에 대해

일반적으로 HTTP는 바이트를 처리합니다. 파이썬 3으로 들어서면서, 모든 `str` 타입은 유니코드로 처리됩니다[1]. 애플리케이션 단에서 인코딩/디코딩을 처리해야하며, 서버로부터 왔다갔다하는 타입은 **반드시** `str` 아니면 `bytes` 여야 합니다. `unicode` 값이 되면 **절대** 안 됩니다.

추가로, status 값이나 response header값에 담기는 값은 `start_response()` Callable로 주고받는 데이터에 response 값을 준비하는 시점, 즉 `write(body_data)` Callable의 리턴값입니다. 이 때는 **반드시** `Latin-1` 포맷(ISO/IEC 8859-1)으로 포매팅 해야합니다.

따라서 WSGI 스펙에서는 "네이티브" 문자열, "Bytestring" 으로 정의합니다.

- 네이티브 문자열
  - 요청/응답의 헤더와 메타데이터로 처리하는 값을 의미합니다.
  - `str` 타입이어야 합니다.
- Bytestring은 요청/응답의 body값에 사용되는 값을 의미합니다.
  - `bytes` 타입이어야 합니다.

## Application/Framework 사이드

Application object는 두 변수를 받는 '호출 가능한' 오브젝트입니다. 실제 객체로서의 오브젝트가 아니라 `__call__` 메소드를 가지고있는 함수, 메소드, 클래스 모두가 될 수 있습니다.

애플리케이션/프레임워크 단이라고 해서 실제로 이를 응용하여 개발하는 사람이 알 필요는 없습니다. 이걸 모르게 꽁꽁숨기는게 애플리케이션/프레임워크 사이드 개발자들의 목표죠.

예시를 살펴봅시다.

```python

```

## Server/Gateway 사이드

## 미들웨어: 양방향으로 작동하는 컴포넌트

# Specification Details

상세 스펙 내용은 일부를 발췌하여 작성하도록 하겠습니다.

# Implementation/Application notes

# 그 외

---

- References

  - [1] `Callable`객체: `__call__()` 메소드를 구현한 객체를 의미합니다.
    - 구현은 알아서 하면 되지만, 호출할 때는 어떤 종류의 `Callable`이 호출되었는지 알지 모르게 해야합니다(종속성 제거를 위함).
    - 해당 콜러블은 자체검사되지 않습니다.
  - [2] 처음 PEP 333이 작성되던 시점에는 파이썬 2가 주력이었죠. 그 때는 `str` 타입이 `ASCII`만을 담을 수 있었다고 합니다. [이 링크](https://sites.pitt.edu/~naraehan/python2/unicode.html)를 참고해주세요!
