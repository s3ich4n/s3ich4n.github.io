{"componentChunkName":"component---src-templates-post-template-post-template-tsx","path":"/books/clean-code/2023-02-03-pt07","result":{"data":{"markdownRemark":{"id":"8fa7195d-e201-50ab-9e68-117812326108","html":"<h1 id=\"7-오류-처리\" style=\"position:relative;\"><a href=\"#7-%EC%98%A4%EB%A5%98-%EC%B2%98%EB%A6%AC\" aria-label=\"7 오류 처리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>7. 오류 처리</h1>\n<p>프로그래머라면 예기치 않은 상황에 대비하기 위해 대비해야할 책임이 있습니다. 이는 깨끗한 코드와 오류 처리가 연관있다는 말입니다. 따라서 오류를 체계적으로 잘 정리할 필요가 있겠습니다.</p>\n<h2 id=\"오류-코드보단-예외를-사용하자\" style=\"position:relative;\"><a href=\"#%EC%98%A4%EB%A5%98-%EC%BD%94%EB%93%9C%EB%B3%B4%EB%8B%A8-%EC%98%88%EC%99%B8%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EC%9E%90\" aria-label=\"오류 코드보단 예외를 사용하자 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>오류 코드보단 예외를 사용하자</h2>\n<p>옛날 프로그래밍 언어에는 예외를 제공하지 않아서 에러코드로 처리했다고 합니다. 문제가 발생하면 에러코드도 함께 확인했어야 했죠. 하지만, 이제는 다릅니다. 로직과 오류처리 코드를 분리할 수 있습니다.</p>\n<h2 id=\"try-catch-finally-구문부터-쓰자\" style=\"position:relative;\"><a href=\"#try-catch-finally-%EA%B5%AC%EB%AC%B8%EB%B6%80%ED%84%B0-%EC%93%B0%EC%9E%90\" aria-label=\"try catch finally 구문부터 쓰자 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>try-catch-finally 구문부터 쓰자</h2>\n<p>이 구문을 사용하면 예외를 통해 로직이 실행되는 문제의 범위를 지정할 수 있습니다. <code class=\"language-text\">try</code> 구문에서 문제가 생기면 실행중단 후 <code class=\"language-text\">catch</code> 블록으로 로직을 옮길 수 있습니다.</p>\n<p>트랜잭션과 비슷하다고 할 수 있겠습니다. 이 구문을 통해 프로그램의 상태를 일관성있게 유지하는 것이 목표이기 때문입니다. 그러므로 예외가 발생할 수 있는 로직은 try-catch-finally 구문 안에 배치하는 편이 좋습니다.</p>\n<p>이 경우에는 <a href=\"https://docs.python.org/3/library/unittest.html#unittest.TestCase.assertRaises\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">assertRaises()</a> 를 사용해서 TDD를 구현하면 되겠지요.</p>\n<h2 id=\"미확인unchecked-예외를-사용하자-java-이야기입니다\" style=\"position:relative;\"><a href=\"#%EB%AF%B8%ED%99%95%EC%9D%B8unchecked-%EC%98%88%EC%99%B8%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EC%9E%90-java-%EC%9D%B4%EC%95%BC%EA%B8%B0%EC%9E%85%EB%8B%88%EB%8B%A4\" aria-label=\"미확인unchecked 예외를 사용하자 java 이야기입니다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>미확인(unchecked) 예외를 사용하자 (Java 이야기입니다)</h2>\n<p>옛날 자바는 메소드 선언 시 메소드가 반환할 예외를 모두 열거했습니다. 메소드가 반환하는 예외는 메소드 유형의 일부였습니다. 코드가 메소드를 사용하는 방식이 메소드 선언과 맞지 않으면 컴파일도 못했다고 합니다.</p>\n<p>그렇지만 확인된 예외를 사용하지 않게된 이유는 아래와 같습니다.</p>\n<ol>\n<li>OCP 를 위반합니다. 확인된 예외를 던졌는데 catch 블록이 세 단계 위에 있다면 그 사이 메소드 모두가 선언부에 해당 예외를 정의해야 합니다.\n→하위 단계에서 코드를 고치면 상위 단계 메소드를 모두 고치고 새로 빌드한 후 배포해야한다는 말입니다.</li>\n</ol>\n<p>이 글들을 먼저 읽어보시는 것을 추천드립니다. <a href=\"https://www.geeksforgeeks.org/checked-vs-unchecked-exceptions-in-java/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Checked Exceptions v. Unchecked Exceptions 기본 설명</a> , <a href=\"https://velog.io/@sangmin7648/%EB%8B%B9%EC%8B%A0%EC%9D%98-Checked-Exception%EC%9D%80-%ED%95%84%EC%9A%94-%EC%97%86%EB%8B%A4#1-openclosed-%EC%9B%90%EC%B9%99%EC%9D%98-%EC%9C%84%EB%B0%B0\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Checked Exception이 꺼려지는 이유에 대한 국내 아티클</a> 을 소개합니다.</p>\n<p>정리해보자면 자바의 설계상 안전한 소프트웨어를 구현하기 위한 도구였으나 그렇게 되지 못했다 라고 이해했습니다.</p>\n<h2 id=\"예외에-의미를-제공하라\" style=\"position:relative;\"><a href=\"#%EC%98%88%EC%99%B8%EC%97%90-%EC%9D%98%EB%AF%B8%EB%A5%BC-%EC%A0%9C%EA%B3%B5%ED%95%98%EB%9D%BC\" aria-label=\"예외에 의미를 제공하라 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>예외에 의미를 제공하라</h2>\n<p>예외를 던질때는 호출스택 뿐 아니라, 오류 메시지에 적절한 정보를 담을 필요가 있습니다. 가능하다면 앱이 로그를 찍어서 디버깅하기 편하기 만들어줍니다.</p>\n<h2 id=\"호출자를-고려해-예외-클래스를-정의하라\" style=\"position:relative;\"><a href=\"#%ED%98%B8%EC%B6%9C%EC%9E%90%EB%A5%BC-%EA%B3%A0%EB%A0%A4%ED%95%B4-%EC%98%88%EC%99%B8-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%A5%BC-%EC%A0%95%EC%9D%98%ED%95%98%EB%9D%BC\" aria-label=\"호출자를 고려해 예외 클래스를 정의하라 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>호출자를 고려해 예외 클래스를 정의하라</h2>\n<p>애플리케이션 단에서는 오류를 잘 잡을 궁리를 해야합니다.</p>\n<p>외부 라이브러리에서 던지는 모든 에러를 메인 로직에서 모두 캐치하려고 할 것이 아니라, 호출하는 라이브러리를 감싸서 거기서 발생하는 모든 에러를 wrapping 하는 편이 훨씬 깔끔합니다. 이 기법의 장점은 아래와 같습니다:</p>\n<ol>\n<li>외부 라이브러리 API의 예외를 wrapper 클래스에서 처리할 수 있습니다.</li>\n<li>라이브러리를 갈아타도 코드 변경에 대한 비용이 적습니다.</li>\n<li>특정 라이브러리에 발목잡히지 않습니다.</li>\n</ol>\n<h2 id=\"정상-흐름을-정의하라\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EC%83%81-%ED%9D%90%EB%A6%84%EC%9D%84-%EC%A0%95%EC%9D%98%ED%95%98%EB%9D%BC\" aria-label=\"정상 흐름을 정의하라 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정상 흐름을 정의하라</h2>\n<p>상기 이야기대로 코드를 짜더라도, 로직 중단이 적합하지 않을 때가 있습니다. 이럴 땐 리팩토링에 나오는 SPECIAL CASE PATTERN이 적합합니다[1].</p>\n<ol>\n<li>일단 원하는 로직을 풀어둡시다.</li>\n<li>특수사례를 클래스 혹은 객체 안에서 해소하게 묶고 결과를 리턴하게 만듭니다.</li>\n</ol>\n<h2 id=\"null을-리턴하지-마라\" style=\"position:relative;\"><a href=\"#null%EC%9D%84-%EB%A6%AC%ED%84%B4%ED%95%98%EC%A7%80-%EB%A7%88%EB%9D%BC\" aria-label=\"null을 리턴하지 마라 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"language-text\">null</code>을 리턴하지 마라</h2>\n<p>악명높은 <code class=\"language-text\">NullPointerException</code>이 어디서 터질지 캐치하기 힘든 로직을 짜지않기를 주문하는 글입니다. 대체 어디서 온 <code class=\"language-text\">null</code> 인지 알 수 없도록 코드를 짜지 않고, 이에 대한 해결책으로 앞서말한 SPECIAL CASE PATTERN을 다시 소개합니다.</p>\n<h2 id=\"null을-전달하지-마라\" style=\"position:relative;\"><a href=\"#null%EC%9D%84-%EC%A0%84%EB%8B%AC%ED%95%98%EC%A7%80-%EB%A7%88%EB%9D%BC\" aria-label=\"null을 전달하지 마라 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"language-text\">null</code>을 전달하지 마라</h2>\n<p>마찬가지로, <code class=\"language-text\">null</code>을 메소드로 전달하는 것은 더 악질이라고 합니다. 진짜 어디서 문제가 발생할지 잡기 더 힘들 것으로 보입니다… 저자는 해결책으로 아래 내용을 소개합니다.</p>\n<ol>\n<li>안좋은 케이스에 대해 새 Exception 을 만들고, 안좋은 케이스를 맞닥뜨렸을 때 이를 사용하는 것을 권합니다.</li>\n<li><code class=\"language-text\">assert</code> 구문을 사용해서 아예 Exception을 발생시킵니다.</li>\n</ol>\n<p>아예 <code class=\"language-text\">null</code>을 못받도록 하는 것이 합리적이라고 합니다.</p>\n<h2 id=\"결론\" style=\"position:relative;\"><a href=\"#%EA%B2%B0%EB%A1%A0\" aria-label=\"결론 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>결론</h2>\n<p>읽기 좋은 코드 뿐 아니라 안정성 있는 코드 또한 고려해야합니다. 오류처리를 프로그램 논리와 분리하여 관심사를 각각 분리하고 이를 통해 로직(에러든 본디 로직이든)에 집중할 수 있도록 합시다.</p>\n<hr>\n<p>References</p>\n<ul>\n<li>[1]: 상세한 내용은 리팩토링 개정 2판의 ‘10.5 - 특이 케이스 추가하기’ 를 참고하십시오.</li>\n</ul>","fields":{"slug":"/books/clean-code/2023-02-03---chapter07//books/clean-code/2023-02-03-pt07","tagSlugs":["/tag/book-review/","/tag/code-quality/"]},"frontmatter":{"date":"2023-02-03T22:51:00.000Z","description":"2023년 1월부터 시작한 클린 코드 독파 스터디 후, 매 모임 전 준비하는 게시글을 공유합니다. 이 글은 7장, 오류 처리에 대해 설명합니다.","tags":["book_review","code_quality"],"title":"클린 코드 스터디 (7): 오류 처리","socialImage":{"publicURL":{"publicURL":"/static/483b84108696f21f6329d1cecf5d8a3f/water.jpg"}}}}},"pageContext":{"slug":"/books/clean-code/2023-02-03---chapter07//books/clean-code/2023-02-03-pt07"}},"staticQueryHashes":["251939775","357378587","401334301"]}